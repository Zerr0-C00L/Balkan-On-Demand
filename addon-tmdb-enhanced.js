const { addonBuilder, serveHTTP } = require('stremio-addon-sdk');
const fs = require('fs');
const path = require('path');
const { decompressFromEncodedURIComponent } = require('lz-string');
const express = require('express');
const { getRouter } = require('stremio-addon-sdk');

// Load TMDB ID mapping (generated by create-tmdb-symlinks.js)
let tmdbMapping = { movies: {}, series: {} };
const mappingPath = path.join(__dirname, 'data', 'tmdb-id-mapping.json');

try {
  if (fs.existsSync(mappingPath)) {
    tmdbMapping = JSON.parse(fs.readFileSync(mappingPath, 'utf8'));
    console.log(`ðŸ“Š Loaded TMDB mapping: ${Object.keys(tmdbMapping.movies).length} movies, ${Object.keys(tmdbMapping.series).length} series`);
  } else {
    console.warn('âš ï¸  No TMDB mapping found. Run: node scripts/create-tmdb-symlinks.js');
  }
} catch (err) {
  console.error('âŒ Failed to load TMDB mapping:', err.message);
}

// Load content database as fallback
const bauBauDB = JSON.parse(fs.readFileSync(path.join(__dirname, 'data', 'baubau-content.json'), 'utf8'));
console.log(`ðŸ“š Loaded Database: ${bauBauDB.movies.length} movies, ${bauBauDB.series.length} series`);

// TMDB API cache
const tmdbCache = new Map();

// Fetch TMDB metadata
async function fetchTMDBMeta(tmdbId, type = 'movie', apiKey = null) {
  const cacheKey = `${type}:${tmdbId}`;
  
  if (tmdbCache.has(cacheKey)) {
    return tmdbCache.get(cacheKey);
  }
  
  // Use provided API key or environment variable
  const TMDB_API_KEY = apiKey || process.env.TMDB_API_KEY;
  
  if (!TMDB_API_KEY) {
    return null;
  }
  
  try {
    const endpoint = type === 'series' ? 'tv' : 'movie';
    const url = `https://api.themoviedb.org/3/${endpoint}/${tmdbId}?api_key=${TMDB_API_KEY}&language=en-US&append_to_response=credits,videos,external_ids`;
    
    const response = await fetch(url);
    if (!response.ok) throw new Error(`TMDB responded with ${response.status}`);
    
    const data = await response.json();
    
    // Get IMDb ID if available
    const imdbId = data.external_ids?.imdb_id || null;
    
    const result = {
      tmdbId: tmdbId,
      imdbId: imdbId,
      name: data.title || data.name,
      description: data.overview || null,
      poster: data.poster_path ? `https://image.tmdb.org/t/p/w780${data.poster_path}` : null,
      background: data.backdrop_path ? `https://image.tmdb.org/t/p/original${data.backdrop_path}` : null,
      genres: data.genres ? data.genres.map(g => g.name) : [],
      cast: data.credits?.cast ? data.credits.cast.slice(0, 10).map(c => c.name) : [],
      director: data.credits?.crew ? data.credits.crew.filter(c => c.job === 'Director').map(d => d.name) : [],
      year: type === 'series' 
        ? (data.first_air_date ? new Date(data.first_air_date).getFullYear() : null)
        : (data.release_date ? new Date(data.release_date).getFullYear() : null),
      rating: data.vote_average || null,
      runtime: data.runtime || (data.episode_run_time ? data.episode_run_time[0] : null),
      trailers: data.videos?.results ? data.videos.results
        .filter(v => v.type === 'Trailer' && v.site === 'YouTube')
        .map(v => ({ source: v.key, type: 'Trailer' })) : []
    };
    
    tmdbCache.set(cacheKey, result);
    return result;
  } catch (error) {
    console.error(`TMDB fetch error for ${tmdbId}:`, error.message);
    tmdbCache.set(cacheKey, null);
    return null;
  }
}

// Parse TMDB ID from Stremio ID
function parseTMDBId(stremioId) {
  // Handle both TMDB IDs and IMDb IDs
  if (stremioId.startsWith('tmdb:')) {
    return { type: 'tmdb', id: stremioId.replace('tmdb:', '') };
  } else if (stremioId.startsWith('tt')) {
    return { type: 'imdb', id: stremioId };
  }
  return null;
}

// Find streams by TMDB ID
function getStreamsByTMDBId(tmdbId, type, season = null, episode = null) {
  const streams = [];
  
  if (type === 'movie') {
    const movieData = tmdbMapping.movies[tmdbId];
    
    if (movieData && movieData.streams) {
      movieData.streams.forEach((streamUrl, index) => {
        streams.push({
          name: 'Direct HD',
          title: `â­ ${movieData.title}\nðŸŽ¬ Direct HD Stream ${index + 1}`,
          url: streamUrl,
          behaviorHints: {
            bingeGroup: `balkan-tmdb-${tmdbId}`
          }
        });
      });
      
      console.log(`âœ… Found ${streams.length} stream(s) for TMDB ${tmdbId}: ${movieData.title}`);
    } else {
      console.log(`âŒ No streams found for TMDB ${tmdbId}`);
    }
  } else if (type === 'series') {
    const seriesData = tmdbMapping.series[tmdbId];
    
    if (seriesData && seriesData.episodes && season && episode) {
      const seasonKey = `S${String(season).padStart(2, '0')}`;
      const episodeKey = `E${String(episode).padStart(2, '0')}`;
      
      if (seriesData.episodes[seasonKey] && seriesData.episodes[seasonKey][episodeKey]) {
        const ep = seriesData.episodes[seasonKey][episodeKey];
        
        streams.push({
          name: 'Direct HD',
          title: `â­ ${seriesData.title}\nðŸ“º ${seasonKey}${episodeKey}: ${ep.title || 'Episode'}`,
          url: ep.url,
          behaviorHints: {
            bingeGroup: `balkan-tmdb-${tmdbId}`
          }
        });
        
        console.log(`âœ… Found stream for TMDB ${tmdbId} ${seasonKey}${episodeKey}`);
      } else {
        console.log(`âŒ No stream found for TMDB ${tmdbId} ${seasonKey}${episodeKey}`);
      }
    }
  }
  
  return streams;
}

// Parse configuration from URL
function parseConfig(configString) {
  if (!configString) return null;
  
  try {
    const { decompressFromEncodedURIComponent } = require('lz-string');
    const decompressed = decompressFromEncodedURIComponent(configString);
    if (decompressed) {
      const config = JSON.parse(decompressed);
      return config;
    }
  } catch (e) {
    console.error('Failed to parse config:', e.message);
  }
  return null;
}

// Manifest generation
function generateManifest(config = null) {
  return {
    id: 'community.balkan.tmdb.enhanced',
    version: '7.0.0',
    name: 'Balkan On Demand (TMDB Enhanced)',
    description: 'Direct HD streams for Balkan content with TMDB ID integration. Works seamlessly with TMDB catalogs.',
    
    resources: [
      'catalog',
      'meta',
      'stream'
    ],
    
    types: ['movie', 'series'],
    
    // Support both TMDB and IMDb IDs
    idPrefixes: ['tt', 'tmdb', 'bilosta'],
    
    catalogs: [
      {
        id: 'balkan_tmdb_movies',
        name: 'Balkan Movies (TMDB)',
        type: 'movie',
        extra: [
          { name: 'search' },
          { name: 'skip' }
        ]
      },
      {
        id: 'balkan_tmdb_series',
        name: 'Balkan Series (TMDB)',
        type: 'series',
        extra: [
          { name: 'search' },
          { name: 'skip' }
        ]
      }
    ],
    
    behaviorHints: {
      configurable: true,
      configurationRequired: false
    }
  };
}

// Create builder dynamically based on config
function createBuilder(config = null) {
  const manifest = generateManifest(config);
  return new addonBuilder(manifest);
}

// Define handlers on a builder instance
function defineHandlers(builder, config = null) {
  const tmdbApiKey = config?.tmdbApiKey || process.env.TMDB_API_KEY;
  
  // CATALOG Handler
  builder.defineCatalogHandler(async ({ type, id, extra }) => {
  console.log(`ðŸ“– Catalog request: ${id} (type: ${type}), extra:`, extra);
  
  const limit = 100;
  const skip = parseInt(extra.skip) || 0;
  const search = extra.search || '';
  
  let metas = [];
  
  if (type === 'movie') {
    // Get all movies with TMDB mapping
    for (const [tmdbId, movieData] of Object.entries(tmdbMapping.movies)) {
      if (search && !movieData.title.toLowerCase().includes(search.toLowerCase())) {
        continue;
      }
      
      // Fetch TMDB metadata with API key from config
      const tmdbMeta = await fetchTMDBMeta(tmdbId, 'movie', tmdbApiKey);
      
      if (tmdbMeta) {
        metas.push({
          id: `tmdb:${tmdbId}`,
          type: 'movie',
          name: tmdbMeta.name,
          poster: tmdbMeta.poster,
          posterShape: 'poster',
          background: tmdbMeta.background,
          description: tmdbMeta.description,
          releaseInfo: tmdbMeta.year ? tmdbMeta.year.toString() : null,
          imdbRating: tmdbMeta.rating ? tmdbMeta.rating.toFixed(1) : null
        });
      }
    }
  } else if (type === 'series') {
    // Get all series with TMDB mapping
    for (const [tmdbId, seriesData] of Object.entries(tmdbMapping.series)) {
      if (search && !seriesData.title.toLowerCase().includes(search.toLowerCase())) {
        continue;
      }
      
      const tmdbMeta = await fetchTMDBMeta(tmdbId, 'series', tmdbApiKey);
      
      if (tmdbMeta) {
        metas.push({
          id: `tmdb:${tmdbId}`,
          type: 'series',
          name: tmdbMeta.name,
          poster: tmdbMeta.poster,
          posterShape: 'poster',
          background: tmdbMeta.background,
          description: tmdbMeta.description,
          releaseInfo: tmdbMeta.year ? tmdbMeta.year.toString() : null,
          imdbRating: tmdbMeta.rating ? tmdbMeta.rating.toFixed(1) : null
        });
      }
    }
  }
  
  // Sort by year (newest first)
  metas.sort((a, b) => {
    const yearA = parseInt(a.releaseInfo) || 0;
    const yearB = parseInt(b.releaseInfo) || 0;
    return yearB - yearA;
  });
  
  // Paginate
  metas = metas.slice(skip, skip + limit);
  
  return { metas };
});

// META Handler
builder.defineMetaHandler(async ({ type, id }) => {
  console.log(`â„¹ï¸  Meta request: ${id} (type: ${type})`);
  
  const parsed = parseTMDBId(id);
  
  if (!parsed) {
    console.log(`âŒ Invalid ID format: ${id}`);
    return { meta: null };
  }
  
  let tmdbId = parsed.id;
  
  // If IMDb ID, try to find corresponding TMDB ID
  if (parsed.type === 'imdb') {
    // Search our mapping for matching IMDb ID
    // This requires fetching TMDB data for all items (expensive)
    // Better approach: pre-cache IMDb IDs in mapping file
    console.log(`âš ï¸  IMDb ID lookup not yet implemented: ${id}`);
    return { meta: null };
  }
  
  // Fetch full TMDB metadata
  const tmdbMeta = await fetchTMDBMeta(tmdbId, type);
  
  if (!tmdbMeta) {
    return { meta: null };
  }
  
  const meta = {
    id: id,
    type: type,
    name: tmdbMeta.name,
    poster: tmdbMeta.poster,
    posterShape: 'poster',
    background: tmdbMeta.background,
    logo: null,
    description: tmdbMeta.description || '',
    releaseInfo: tmdbMeta.year ? tmdbMeta.year.toString() : '',
    genres: tmdbMeta.genres,
    cast: tmdbMeta.cast,
    director: tmdbMeta.director,
    imdbRating: tmdbMeta.rating ? tmdbMeta.rating.toFixed(1) : null,
    runtime: tmdbMeta.runtime ? `${tmdbMeta.runtime} min` : null,
    trailers: tmdbMeta.trailers.map(t => ({
      source: `https://www.youtube.com/watch?v=${t.source}`,
      type: t.type
    }))
  };
  
  // Add videos array for series
  if (type === 'series') {
    const seriesData = tmdbMapping.series[tmdbId];
    
    if (seriesData && seriesData.episodes) {
      meta.videos = [];
      
      for (const [seasonKey, episodes] of Object.entries(seriesData.episodes)) {
        const seasonNum = parseInt(seasonKey.substring(1));
        
        for (const [episodeKey, episodeData] of Object.entries(episodes)) {
          const episodeNum = parseInt(episodeKey.substring(1));
          
          meta.videos.push({
            id: `tmdb:${tmdbId}:${seasonNum}:${episodeNum}`,
            title: episodeData.title || `Episode ${episodeNum}`,
            season: seasonNum,
            episode: episodeNum,
            released: new Date().toISOString()
          });
        }
      }
    }
  }
  
  return { meta };
});

// STREAM Handler
builder.defineStreamHandler(async ({ type, id }) => {
  console.log(`ðŸŽ¬ Stream request: ${id} (type: ${type})`);
  
  // Parse ID (could be tmdb:12345 or tmdb:12345:1:1 for series)
  const parts = id.split(':');
  
  if (parts[0] !== 'tmdb') {
    console.log(`âŒ Not a TMDB ID: ${id}`);
    return { streams: [] };
  }
  
  const tmdbId = parts[1];
  const season = parts[2] ? parseInt(parts[2]) : null;
  const episode = parts[3] ? parseInt(parts[3]) : null;
  
  const streams = getStreamsByTMDBId(tmdbId, type, season, episode);
  
  return { streams };
  });
  
  return builder;
}

// Create default builder
const defaultBuilder = createBuilder(null);
defineHandlers(defaultBuilder);

// Express server setup
const PORT = process.env.PORT || 7007;
const app = express();

app.use(express.json());

// Serve configure app
app.use('/configure', express.static(path.join(__dirname, 'dist')));

// Redirect root to configure
app.get('/', (req, res) => {
  res.redirect('/configure');
});

// Handle manifest requests with optional configuration
app.get('/:config?/manifest.json', (req, res) => {
  const configString = req.params.config;
  const config = parseConfig(configString);
  
  const manifest = generateManifest(config);
  
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Headers', '*');
  res.setHeader('Content-Type', 'application/json');
  res.json(manifest);
});

// Default router (no config)
const defaultRouter = getRouter(defaultBuilder.getInterface());

// Handle addon routes with or without config prefix
app.use((req, res, next) => {
  const path = req.path;
  const pathParts = path.split('/').filter(p => p);
  
  // Check if this is a direct addon route without config
  if (path.startsWith('/catalog/') || path.startsWith('/meta/') || path.startsWith('/stream/')) {
    return defaultRouter(req, res, next);
  }
  
  // Check if path has config prefix
  if (pathParts.length > 1) {
    const firstPart = pathParts[0];
    const secondPart = pathParts[1];
    
    // If second part is catalog/meta/stream, first part is likely the config
    if (secondPart === 'catalog' || secondPart === 'meta' || secondPart === 'stream') {
      const configString = firstPart;
      const config = parseConfig(configString);
      
      if (config) {
        console.log(`ðŸ”§ Config request with TMDB key: ${config.tmdbApiKey ? 'âœ…' : 'âŒ'}`);
        
        // Create a builder for this specific configuration
        const builder = createBuilder(config);
        defineHandlers(builder, config);
        
        // Modify the request path to remove the config prefix
        req.url = '/' + pathParts.slice(1).join('/');
        
        // Get the router for this builder and use it
        const addonRouter = getRouter(builder.getInterface());
        return addonRouter(req, res, next);
      }
    }
  }
  
  next();
});

app.listen(PORT, () => {
  console.log(`\nðŸš€ Balkan On Demand (TMDB Enhanced) v7.0.0 running on http://localhost:${PORT}\n`);
  console.log(`ðŸ“Š TMDB Mapping Stats:`);
  console.log(`   â€¢ Movies: ${Object.keys(tmdbMapping.movies).length} mapped`);
  console.log(`   â€¢ Series: ${Object.keys(tmdbMapping.series).length} mapped`);
  console.log(`\nâœ… TMDB Integration Features:`);
  console.log(`   ðŸŽ¯ Direct TMDB ID support (tmdb:12345)`);
  console.log(`   ðŸ“Š Full TMDB metadata (descriptions, cast, ratings)`);
  console.log(`   ðŸ”— IMDb ID support (coming soon)`);
  console.log(`   âš¡ Fast stream lookup via ID mapping`);
  console.log(`\nðŸ“– Usage:`);
  console.log(`   1. Generate mapping: TMDB_API_KEY=xxx node scripts/create-tmdb-symlinks.js`);
  console.log(`   2. Start addon: TMDB_API_KEY=xxx node addon-tmdb-enhanced.js`);
  console.log(`   3. Install: http://localhost:${PORT}/manifest.json\n`);
});
